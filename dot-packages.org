#+TITLE:Dot Emacs:  Packages
#+AUTHOR: Brad Collins
#+EMAIL: brad@chenla.la
#+PROPERTY: header-args    :results drawer  :tangle emacs-packages.el

* Introduction

There are a number of different ways of adding packages to Emacs, each
method is a built on top another.  It isn't a bad idea to take  a
minute to look at how we got to where we are today.

** Primordial Software Management

Install by hand.  Until just a few years ago this was the only way to
add things to emacs.  You put your code in a directory relative to
'.emacs-lisp' or '.emacs.d' directories and then add the path to that
directory in your init file and then either 'require' or 'load' the
package.  It was up to you to keep track of and update any of this
code.  It was good for a very long time, because deep down we all love
tweaking our init files.  And then one day it wasn't.  

** The First Coming: The Age of Packages Begins

In Emacs 2X.X all of that changed when Emacs got a proper Packaging
system.  The world would never be quiet the same again. Packages work
very much the same as apt-get or yum packages in linux.  Packages are,
/well packaged/ and maintained in ELPA and MELPA repositories.  This
makes installation, and upgrading a trivial process using the /Emacs
Package Manager/.  The package manager really is fantastic, especially
for people new to Emacs.  But as in all things, if you make something
friendly and easy to use for beginners it is almost inevitable that it
takes away some features and control that experts require.  The
package manager is the /customize/ method of installing packages.

** The Second Coming: The Great Conciliation

If you have a large hand written init file, it would be far more
consistent to be able to bipass the package manager and install from
your init file which bundles together installation, updating and all
configuration and tweakages.

Enter 'use-package' a lisp-macro from John Weigley which does
everything hardcore emacs tweakers needed and more.  It leveraged the
power of emacs packages inside the comforting monstrocity that is the
average hand-written emacs init file.

** The Rapture: Is there a Rapture?  

What's next, is there a /rapture/ or at at least a Singularity we can
look forward to?  These things are unknown.  However we would be
remiss to not mention what is likely the embryonic seed from which the
Singularity will emerge from, and that of course is Orgmode and Org
Babel and how it has made possible both Literate Programing and
Literate Computing...

** How Use-Package Works

* Packages
** File Header 

#+begin_src emacs-lisp
;; -*- mode: EMACS-LISP; fill-column: 75; comment-column: 50; -*-
;; Use-Package
#+end_src

** Unicode Fonts

We use the `unicode-fonts' package to set everything up. Beware that
the `unicode-fonts-setup' function takes a while to run, which is why
this module isn't always on by default.

You'll need to make sure the necessary fonts are installed for this to
work. See https://github.com/rolandwalker/unicode-fonts/#quickstart

#+begin_src emacs-lisp

;; Unicode Fonts ===========================================

(use-package unicode-fonts
  :ensure t
  :config
  (unicode-fonts-setup))

#+end_src


** Color Theme: Gruvbox

Emacs packages provided a nice way to add color schemes to Emacs.
Previously there was a theme manager application which bundled a lot
of themes together and provided an interface to choose one.

[[https://github.com/greduan/emacs-theme-gruvbox][Gruvbox Theme]] is one of the new generation of emacs color themes
designed to work equally well in terminal windows as they do in X11.
There is obviously a great deal of love lavished on these themes and
all of the hard work that went into them has paid off.  Modern emacs
is far more than an editor, and these themes cover the base editor and
add-on packages including Helm, Mu4e etc.

I had been a holdout for a number of years, clinging to the theme I'd 
been using for nearly a decade; 'calm-forest'.  There are still a few
things in Gruvbox that I thought worked better in calm-forest, but all
in all this theme is really fucking good.  YMMV.

#+begin_src emacs-lisp

;; Gruvbox Theme ===========================================
;; https://github.com/greduan/emacs-theme-gruvbox

(use-package gruvbox-theme
  :ensure t
  :config
  (load-theme 'gruvbox t))

#+end_src

** Winmove

Use hydra for key-bindings

#+begin_src emacs-lisp

;; Winmove =================================================

(use-package windmove
  ;; :defer 4
  :ensure t
  :config
  ;; use command key on Mac
  ;;(windmove-default-keybindings 'hyper)
  ;; wrap around at edges
  (setq windmove-wrap-around t))

#+end_src


** Buffer Move

 - [[https://github.com/lukhas/buffer-move][lukhas/buffer-move]] | GitHub

Use hydra for key-bindings

#+begin_src emacs-lisp

;; Buffer Move =============================================

(use-package buffer-move
  :ensure t
  :config
  )
#+end_src


** Avy Jump Mode

#+begin_src emacs-lisp

;; Avy Jump Mode ===========================================

(use-package avy
  :ensure t
  :config
  (setq avy-all-windows 'all-frames)
  (global-set-key (kbd "C-,") 'avy-goto-char-2)
  (global-set-key (kbd "C-.") 'avy-goto-word-1))

#+end_src

** UUID Generators

See [[rfc:4122][RFC4122]]

M-x uuidgen inserts a uuid -- but I haven't worked out how to call
this programically -- for now just doing it using (org-new-id)


#+begin_src emacs-lisp
;; UUID Generators =========================================
;; See [[rfc:4122][RFC4122]]
;; M-x uuidgen inserts a uuid -- but I haven't worked out
;; how to call this programically -- for now just doing it
;; using (org-new-id)

(use-package uuidgen
  :ensure t
  )

#+end_src


** Powerline

Powerline can be thought of as eye-candy, but it's very nice eye-candy
that (at least for me) makes the command line far more readable.  I
remember when I first installed it, before packages, and it took me
almost a whole day to get it to work.  Now it's just three lines of
config...

#+begin_src emacs-lisp

;; Powerline ===============================================
(use-package powerline
  :ensure t
  :init
  (powerline-default-theme)
  (setq powerline-color1 "#C05800")
  (setq powerline-color2 "#839496")
  (setq powerline-arrow-shape 'arrow))

#+end_src

** eShell

I am one of those people who admire eshell and yet have never gotten
into the habit of using it on a regular basis. I now use [[https://github.com/Guake/guake][Guake]]
pulldown terminal emulator outside of emacs.

I think once I start using tramp more in my workflow for managing
servers I will start to use eShell more.  But for now...

When I do start to use eShell in earnest, these links are a good place
to start:

 - [[http://cestlaz.github.io/posts/using-emacs-27-shell/#.WKFrkbMxVph][Using Emacs - 27 - shell and eshell]] | C'est la Z
 - [[https://www.masteringemacs.org/article/complete-guide-mastering-eshell][Mastering Eshell]] Mastering Emacs

#+begin_src emacs-lisp

;; eshell ===================================================
(use-package eshell-git-prompt
  :ensure t
  :config
  (eshell-git-prompt-use-theme 'robbyrussell))

;; Define a keybinding to get to your eshell quickly.
(global-set-key (kbd "C-c e") 'eshell)

;; Visual commands are commands which require a proper terminal.
;; eshell will run them in a term buffer when you invoke them.
(setq eshell-visual-commands
      '("less" "tmux" "htop" "top" "bash" "zsh" "fish"))
(setq eshell-visual-subcommands
      '(("git" "log" "l" "diff" "show")))

#+end_src

** EMMS

EMMS is the Emacs Multi-Media System.  EMMS has been around a while
and is still in active development.  I've played with it a couple of
times, but it doesn't seem to be to handle very large media
collections like mine.  My music alone is nearly two terrabytes.

Every other year or so, I stumble across it and try it again.  At the
moment it doesn't fit my needs so it's commented out until next time.

Good places to start, when /playing/ around with it:

  - [[https://www.gnu.org/software/emms/][Emacs Multimedia System]] | EMMS Home on gnu.org
  - [[https://www.emacswiki.org/emacs/EMMS][EMMS]] | Emacs Wiki

#+begin_src emacs-lisp

;; emms ====================================================

;;(use-package emms
;;  :ensure t
;;  :config
;;  (progn
;;    (emms-standard)
;;    (emms-default-players)
;;    (setq emms-playlist-buffer-name "Music-EMMS")
;;    (setq emms-source-file-default-directory "/media/deerpig/green/music")))

#+end_src

** WC-Org

Displays word count in modeline of org buffers.

Can be customized using `defcustom wc-linemode-format'

See http://ireal.blog/?p=6722


#+begin_src emacs-lisp

;; WC-Org ==================================================
;; (add-hook 'org-mode-hook 'wc-mode)
;; Displays word count in modeline of org buffers.
;; Can be customized using `defcustom wc-linemode-format'
;; See http://ireal.blog/?p=6722

(use-package wc-mode
  :ensure t
  )

#+end_src

** Org Wiki

;; Org-wiki ================================================

;; (use-package org-wiki
;;   :ensure t
;;   :init
;;   )

;; https://github.com/caiorss/org-wiki

 ;; (let ((url "https://raw.githubusercontent.com/caiorss/org-wiki/master/org-wiki.el"))     
 ;;       (with-current-buffer (url-retrieve-synchronously url)
 ;; 	(goto-char (point-min))
 ;; 	(re-search-forward "^$")
 ;; 	(delete-region (point) (point-min))
 ;; 	(kill-whole-line)
 ;; 	(package-install-from-buffer)))


** Org Ref

Org-Ref is nothing short of mindblowing!  

#+begin_quote
org-ref: citations, cross-references, indexes, glossaries and bibtex
utilities for org-mode
#+end_quote

And yet I'm not using it... yet.  But I have a good excuse :)

References are an important part of what we will integrate into BMF.
At present I maintain a BibTex database like many other scholars and
scientists.  But my next step will be to convert the BibTex database
into a literate BibTex database -- where each reference will be a
separate heading and include a lot more information than you can
presently keep inside BibTex.  The idea is to then tangle the file so
that a traditional BibTex database is generated.  That's not
difficult, but I am still not sure how this will interact with Org-Ref
which is very much based on the BibTex textfile database world.  There
are so many cool lookup tools in Org-Ref that I want to work out how
to be able to add references from Org-Ref and still have a primary
reference database that will be using BMF Literate References.

So until I can set aside a block of time to tackle this, it will
remain commented out :(

When I do tackle it, this is where to begin:

  - [[https://github.com/jkitchin/org-ref][Org-Ref]] | jkitchin GitHub
  - [[https://www.youtube.com/watch?v=2t925KRBbFc][Org Ref]] | YouTube

#+begin_src emacs-lisp

;; Org-Ref =================================================
;; 
;; Org-ref is for interactively adding references to org documents
;; as they are being composed and exported.

;; (use-package org-ref
;;   :ensure t
;;   :config
;;   (setq reftex-default-bibliography '("~/org/biblio.bib"))
;;   (setq org-ref-ref-library 'org-ref-helm-cite)
  
;;   (setq org-ref-bibliography-notes    "~/org/biblio.bib"
;; 	org-ref-default-bibliography  "~/org/bibtex-pdfs"
;; 	org-ref-pdf-directory         "~/htdocs/lib")

;;   (setq bibtex-completion-bibliography "~/org/biblio.bib"
;; 	bibtex-completion-library-path "~/htdocs/lib"
;; 	bibtex-completion-notes-path   "~/org")
  
  ;; open pdf with system pdf viewer (works on mac)
  ;; (setq bibtex-completion-pdf-open-function
  ;; 	(lambda (fpath)
  ;; 	  (start-process "open" "*open*" "open" fpath)))
;;  )

#+end_src


** SSH

#+begin_src emacs-lisp

;; SSH =====================================================

;; may or may not help emacs not prompt for ssh key passphrases

(use-package exec-path-from-shell
  :ensure t
  :config
  (exec-path-from-shell-copy-env "SSH_AGENT_PID")
  (exec-path-from-shell-copy-env "SSH_AUTH_SOCK"))

#+end_src

** Which Key

which-key is a minor mode for Emacs that displays the key bindings
following your currently entered incomplete command (a prefix) in a
popup.

This cuts down on the need for a many hydras.  I love hydra but it's
better at creating little alternate universes to do specialized
things.

home: [[https://github.com/justbur/emacs-which-key][emacs-which-key]] | github
      [[http://irreal.org/blog/?p=5156][Which Key]] | Irreal

#+begin_src emacs-lisp
(use-package which-key
  :ensure t
  :config 
  (which-key-setup-side-window-right)
  (which-key-mode)
)
#+end_src

#+RESULTS:
: t

** Git Packages

 - [[http://www.wikemacs.org/wiki/Git#Colorize_Dired_output_depending_on_the_file_git_status][Git]] | WikEmacs


#+begin_src emacs-lisp
;; GIT Packages ============================================
#+end_src
*** Git Library

#+begin_src emacs-lisp
(use-package git
  :ensure t)
#+end_src

*** Magit

Magit, along with Orgmode and Helm have transformed the way I use
Emacs more than perhaps any other.  But there is a learning curve --
but most of that learning curve is getting your head around Git and
how to /think/ in Git and make it part of nearly every moment of your
workflow. 

Magit actually makes learning and integrating Git into your life far
easier, even though I still only use a fraction of the power of what
Git and Magit can do.

Hmmmm. for someone who doesn't like learning tech skills from YouTube,
there sure are a lot of emacs videos of late.  The thing is, the
videos /aren't/ a good to learn new things.  But they are good at
showing what's possible and demonstrate workflow that is difficult to
do in a document.

Git is one of those subjects where videos can help visualize workflow
and useage patterns.  And if you think I'm rationalizing.... well,
that's my story and I'm sticking to it.

More info & Videos: 

  - [[https://www.youtube.com/watch?v=D1SJ6mFWYyA][Productive Emacs: Magit]] | YouTube

I'm starting to get the hang of simple rebasing, but squashing and
splitting are still beyond me.  These are good places to start:

  - [[https://www.youtube.com/watch?v=vQO7F2Q9DwA&feature=youtu.be][Magit Rebasing]] | YouTube
  - [[http://irreal.org/blog/?p=5514][Rewriting Git History with Rebase in Magit]] | Irreal

Merging diffs is the bane of my existence.  I'm still struggling to
effectively use both smerge and ediff in Magit.  These links are good
starting places:

  - [[http://irreal.org/blog/?p=5651][Merging with smerge]] | Irreal
  - [[https://coderwall.com/p/mcrwag/use-magit-ediff-to-resolve-merge-conflicts][Use magit-ediff to resolve merge conflicts]] | Coderwall
 

#+begin_src emacs-lisp

;; Magit ---------------------------------------------------

(use-package magit
  :ensure t
  :bind
  ("C-x g" . magit-status)
  ("C-x M-g" . magit-dispatch-popup))

#+end_src

*** Git Gutter

Git gutter is a minor mode that indicates lines, in the left-side
/gutter/ of the window that have been added or deleted or changed
since the last comit in a Git repository.

After you've used this for a couple of days you start to wonder how
you ever lived without it.

:home: https://github.com/syohex/emacs-git-gutter

#+begin_src emacs-lisp

;; Git-Gutter ----------------------------------------------
;; :home: https://github.com/syohex/emacs-git-gutter
(use-package git-gutter
  :ensure t
  :config
  ;; use globally
  (global-git-gutter-mode +1)
  ;; add hook if you want to only use for specific modes
  (add-hook 'ruby-mode-hook 'git-gutter-mode)
  (add-hook 'python-mode-hook 'git-gutter-mode))

#+end_src

*** Magithub

Magithub allows you to create new repos in GitHub from within emacs.
I haven't really felt the need for this, though lately I'm been
creating a lot of new GitHub repos.  But I still have it commented out
until I feel the need.

#+begin_src emacs-lisp

;; Magithub ------------------------------------------------
;; SEE: http://jr0cket.co.uk/2017/02/spacemacs-using-magit-with-github.html
;;
;; requires installation of hub, see: https://hub.github.com/
;; which I'm not quite ready to do.

;; (use-package magithub
;;   :ensure t
;;   :after magit
;;   :config (magithub-feature-autoinject t))

#+end_src

*** Git Time Machine

 - [[https://github.com/pidu/git-timemachine][pidu/git-timemachine]] | GitHub


  - p :: Visit previous historic version
  - n :: Visit next historic version
  - w :: Copy the abbreviated hash of the current historic version
  - W :: Copy the full hash of the current historic version
  - g :: Goto nth revision
  - q :: Exit the time machine.

#+begin_src emacs-lisp

;; Git Timemachine -----------------------------------------

(use-package  git-timemachine
  :ensure t
)

#+end_src
*** Dired K

Highlights contents of git repository directories in dired like in [[https://github.com/supercrabtree/k][k]]
in z-shell.

After you get used to git-gutter this is the next logical step.  I
like it, but would like to see the option of having a view mode that
matched git-gutter.  But then again perhaps not.

I also like the human readable size colors which go from green to red,
indicating the file size.  And having timestamps that gradually fade
is very nice as well.

- [[https://github.com/syohex/emacs-dired-k][syohex/emacs-dired-k]] | GitHub


#+begin_src emacs-lisp
;; Dired K =================================================

(use-package dired-k
  :ensure t
  :config 
  (setq dired-k-human-readable t)
  (define-key dired-mode-map (kbd "K") 'dired-k)
  ;; You can use dired-k alternative to revert-buffer
  (define-key dired-mode-map (kbd "g") 'dired-k)

  ;; always execute dired-k when dired buffer is opened
  (add-hook 'dired-initial-position-hook 'dired-k)

  (add-hook 'dired-after-readin-hook #'dired-k-no-revert))
#+end_src


** Yas-snippet 


Clone AndreaCrotti's yasnippet collection:

   https://github.com/AndreaCrotti/yasnippet-snippets.git 

I put the directories under the ~/.dotfiles/emacs.d/ directory so that
snippets are kept in sync between boxes.  yasmate snippets end in an
underscore -- so in an org file, dot_ and then <TAB> will insert the
snippets.  Install all custom snippets into the snippets directory
when you hit C-c C-c when you create a new snippet and then run M-x
yas-reload-all.  M-x yasnippet-describe-tables will show available
snippets for the mode you are in.

#+begin_src emacs-lisp
  ;; YASNIPPET ================================================

  (use-package yasnippet
    :ensure t
    :config
    ;; (setq yas-snippet-dirs
    ;;   '("~/.dotfiles/emacs.d/yasnippets/snippets/"
    ;;     "~/.dotfiles/emacs.d/yasnippets/yasmate/"
    ;;     "~/.dotfiles/emacs.d/yasnippets/bootstrap/"))
    (setq warning-suppress-types '(yasnippet backquote-change))
    ;;(add-to-list 'warning-suppress-types '(yasnippet backquote-change))
    ;;(define-key yas-minor-mode-map (kbd "<tab>") 'yas-expand)
    ;;(define-key yas-minor-mode-map (kbd "TAB") 'yas-expand)
    )

    (yas-global-mode 1)
    (yas-reload-all)
#+end_src

** Programing Languages

#+begin_src emacs-lisp

;; Programing Languages ====================================
;; Except Lisp, which has it's own file.

#+end_src

*** PHP


#+begin_src emacs-lisp

;; PHP =====================================================

(use-package php-mode
  :ensure t
  )

#+end_src

*** Ruby

#+begin_src emacs-lisp

;; Ruby ====================================================

(use-package ruby-mode
  :ensure t
  :mode "\\.rb\\'"
  :interpreter "ruby")

#+end_src

*** Python

#+begin_example

;; Python ==================================================

(use-package python-mode
  :ensure t)

#+end_example

** Dictionaries

#+begin_src emacs-lisp

;; Dictionaries and Word Definitions =======================

;; Define Word 
;; looks up definition online in word-nik
;; (use-package define-word
;;   :ensure t
;;   )
 (use-package dictionary
   :ensure t
   )

#+end_src

** Boxquote

#+begin_src emacs-lisp

;; Boxquote =================================================

(use-package boxquote
  :ensure t )

#+end_src

** Lorem ipsum

#+begin_src emacs-lisp

;; Lorem ipsum ==============================================

(use-package lorem-ipsum
  :ensure t)

#+end_src

** Twittering Mode

#+begin_src emacs-lisp

;; Twittering ===============================================

  (use-package twittering-mode
  :ensure t
  :config
  (setq twittering-use-master-password t)
  (setq twittering-icon-mode t)         ; Show icons
  (setq twittering-timer-interval 300)  ; Update timeline each 300 seconds
  (setq twittering-url-show-status nil) ; Keeps the echo area from
 				        ; showing all the http processes
  )

#+end_src

** Elfeed


 - [[https://github.com/skeeto/elfeed][skeeto/elfeed]]  | Github
 - [[https://github.com/algernon/elfeed-goodies][elfeed-goodies]] | Github
 - [[https://github.com/remyhonig/elfeed-org][elfeed-org]]     | Github
 - [[http://cestlaz.github.io/posts/using-emacs-29%20elfeed/#.WK-eQLMxVph][Using Emacs #29 -elfeed part 1]] | C'est la Z

 - [[http://nullprogram.com/blog/2013/11/26/][Elfeed Tips and Tricks]] | null program

#+begin_src emacs-lisp

  ;; elfeed =================================================

  (setq elfeed-db-directory "~/.elfeed")

  (use-package elfeed
    :ensure t
  ;;  :config
  ;;  (setq elfeed-search-filter "@6-months-ago +unread")
    :bind (:map elfeed-search-mode-map
		("q" . bjm/elfeed-save-db-and-bury)
		("Q" . bjm/elfeed-save-db-and-bury)
		("j" . hydra-elfeed/body)
		("J" . hydra-elfeed/body)))

		;;("m" . elfeed-toggle-star)
		;;("M" . elfeed-toggle-star)


  (defun elfeed-mark-all-as-read ()
	(interactive)
	(mark-whole-buffer)
	(elfeed-search-untag-all-unread))

  ;;functions to support syncing .elfeed between machines
  ;;makes sure elfeed reads index from disk before launching
  (defun bjm/elfeed-load-db-and-open ()
    "Wrapper to load the elfeed db from disk before opening"
    (interactive)
    (elfeed-db-load)
    (elfeed)
    (elfeed-search-update--force))

  ;;write to disk when quiting
  (defun bjm/elfeed-save-db-and-bury ()
    "Wrapper to save the elfeed db to disk before burying buffer"
    (interactive)
    (elfeed-db-save)
    (quit-window))

  ;; (defalias 'elfeed-toggle-star
  ;;   (elfeed-expose #'elfeed-search-toggle-all 'star))


  ;; elfeed goodies ======================================

  (use-package elfeed-goodies
    :ensure t
    :init
    (setq elfeed-goodies/entry-pane-position (quote bottom))
    :config
    (elfeed-goodies/setup))

  ;; elfeed-org ==========================================

  (use-package elfeed-org
    :ensure t
    :config
    (elfeed-org)
    (setq rmh-elfeed-org-files (list "~/org/elfeed.org")))

#+end_src

#+RESULTS:
:RESULTS:
t
:END:

** Color Themes

Do I really need this anymore?  If I do this should be moved up with
the Gruvbox section.

#+begin_src emacs-lisp

;; Color Themes ============================================

;; to choose a theme interactively -- M-x color-theme-select
(use-package color-theme
  :ensure t
  )

#+end_src

** WebDev Packages

#+begin_src emacs-lisp

;; WebDev ==================================================

#+end_src

*** nXML Mode

nXML Mode should be now part of emacs -- mXML is still best for
working with XML, but Web-Mode is better for WebDev.

*** HTML Tidy

#+begin_src emacs-lisp

;; HTML Tidy -----------------------------------------------

(use-package tidy
  :ensure t
  )

#+end_src

*** RelaxNG


#+begin_src emacs-lisp

;; RelaxNG Mode --------------------------------------------

(use-package rnc-mode
  :ensure t
  )

#+end_src

*** Htmlize

#+begin_src emacs-lisp

;; Htmlize -------------------------------------------------

(use-package htmlize
  :ensure t
  )

#+end_src


*** Web Mode

#+begin_src emacs-lisp
;; Web-Mode ------------------------------------------------
;;
;; Replacement for html mode.
;;
;; See:
;; :url: http://web-mode.org/ ;; home page
;; :url: http://cestlaz.github.io/posts/using-emacs-21-web-mode/#.WC0t1LMxVhF
(use-package web-mode
    :ensure t
    :config
	 (add-to-list 'auto-mode-alist '("\\.html?\\'" . web-mode))
	 (setq web-mode-engines-alist
	       '(("django"    . "\\.html\\'"))) ;; use for liquid (jekyll)
	 (setq web-mode-ac-sources-alist
	       '(("css" . (ac-source-css-property))
		 ("html" . (ac-source-words-in-buffer ac-source-abbrev))))

(setq web-mode-enable-auto-closing t)
(setq web-mode-enable-auto-quoting t))

#+end_src


*** Rainbow Mode

Once you start using it, you wonder how you every worked with CSS
without it....

#+begin_src emacs-lisp

;; Rainbow mode --------------------------------------------

(use-package rainbow-mode
  :ensure t
  :config
   (autoload 'rainbow-mode "rainbow" nil t nil)
   (add-hook 'css-mode-hook
	     (lambda ()
	       (rainbow-mode 1)))
  )

#+end_src

*** CSS Mode


#+begin_src emacs-lisp

;; CSS Mode ------------------------------------------------

(use-package css-mode
  :ensure t
  :init
  (defalias 'apropos-macrop 'macrop)
  (autoload 'css-mode "css-mode")
  (setq auto-mode-alist       
    (cons '("\\.css\\'" . css-mode) auto-mode-alist))
  )

#+end_src

** CSV Mode

#+begin_src emacs-lisp

;; CSV Mode ================================================

(use-package csv-mode
  :ensure t
  )

#+end_src

** Findr

Do we need this?  Using Helm as find interface

#+begin_src emacs-lisp

;; findr ===================================================

(use-package findr
  :ensure t
  )

#+end_src


** WWTime

#+begin_src emacs-lisp

;; wwtime ==================================================
(use-package wwtime
  :ensure t
  )

#+end_src

** JSON 

Move up with WebDev?

#+begin_src emacs-lisp

;; JSON ====================================================

(use-package json
  :ensure t
  )


#+end_src

** Chef & Cucumber
#+begin_src emacs-lisp

;; Chef & Cucumber =========================================

#+end_src

*** Chef

#+begin_src emacs-lisp

;; Chef ----------------------------------------------------

(use-package chef-mode
  :ensure t
  )

#+end_src

*** Cucumber
#+begin_src emacs-lisp

;; Cucumber ------------------------------------------------

;; (edit .feature files)
(use-package feature-mode
  :ensure t)

#+end_src

** Emacs Lisp Development
#+begin_src emacs-lisp

;; Emacs Lisp Development ==================================

#+end_src

*** Cask
#+begin_src emacs-lisp

;; Cask ----------------------------------------------------

;; (project package management for elisp)
(use-package cask
  :ensure t
  )

#+end_src


*** Ecukes

#+begin_src emacs-lisp

;; Ecukes --------------------------------------------------

;; (cucumber like tests for elisp)
(use-package ecukes
  :ensure t
  )

#+end_src

** Expand-Region

As Mike Zamansky promised, it's really easy to fall in love with this
package.  People outside of emacs don't need to mark regions for
anything accept cut and paste.  In Emacs that's just a common
use-case.

By default it is bound to C-=.

  - [[https://github.com/magnars/expand-region.el][Expand-Region.el]] | GitHub
  - [[http://cestlaz.github.io/posts/using-emacs-17-misc/#.WKhJdbMxVhE][Using Emacs 17 - misc small packages]] | C'est la Z

#+begin_src emacs-lisp

;; Expand Region ===========================================
;; expand the marked region in semantic increments 
;; (negative prefix to reduce region)
;; Bound to C-= by default

(use-package expand-region
:ensure t
:config 
(global-set-key (kbd "C-=") 'er/expand-region))

#+end_src

#+RESULTS:
:RESULTS:
t
:END:

** Hungry Delete

I had tried hungry delete a few years ago, or it might have been
something else that did the same thing and didn't like.  I think it
/was/ just a function that I found on EmacsWiki back in the day.

The /package/ Hungry Delete adds a lot of smarts to concept, and
mostly does what you intend to do.  But it does have a little learning
curve.  If you have say four blank lines and you want to delete all
but one, hungry delete will eat all four and you'll have to add in the
extra line again.  That still saves three keystrokes.

I'll try it out for a while and see if it's a keeper or not.

  - [[https://github.com/nflath/hungry-delete][hungry-delete]] | GitHub
  - [[http://cestlaz.github.io/posts/using-emacs-17-misc/#.WKhJdbMxVhE][Using Emacs 17 - misc small packages]] | C'est la Z

#+begin_src emacs-lisp

;; Hungry Delete ===========================================
;; deletes all the whitespace when you hit backspace or delete
(use-package hungry-delete
:ensure t
:config
(global-hungry-delete-mode))

#+end_src

#+RESULTS:
:RESULTS:
t
:END:

** iEdit

iEdit allows you to edit all instances of a marked region in a buffer.

I've tried multiple cursors, but it is too finicky for my tastes, as
Mike Zamansky said, /iedit combined with narrow region works very
well.

However, I don't use the function from Endless Parenthesis, I had used
it a few years ago -- but now that I'm using which-key, the whole
narrowing keymap pops up using C-x n.

In Org mode, I've set up to use speed keys to narrow-widen, which I
use all the time.  So, taken together, I am happy with the setup and
all I have to remember is C-x n n/w to narrow, highlight the text to
edit and then C-; and you're good to go.

 - [[https://github.com/victorhge/iedit][iedit]] | GitHub
 - [[http://cestlaz.github.io/posts/using-emacs-18-narrow/#.WKlrKLMxVph][Using Emacs - 18 - Narrowing and iedit]] | C'est la Z
 - [[http://endlessparentheses.com/emacs-narrow-or-widen-dwim.html][Emacs narrow-or-widen-dwim]] | Endless Parentheses

#+begin_src emacs-lisp

;; iEdit ===================================================
;; edit all instances of a marked region in a buffer
;; bound to C-;
(use-package iedit
  :ensure t)
#+end_src

#+RESULTS:
:RESULTS:
nil
:END:

** Beacon Mode

Another tip from Mike Zamansky.  I had my doubts by it really is
pretty cool and does help you keep track of the curser when you
scroll (when you scroll -- not when you move the cursor which would be
annoying).

  - [[https://github.com/Malabarba/beacon][beacon]] | GitHub
  - [[http://cestlaz.github.io/posts/using-emacs-17-misc/#.WKhJdbMxVhE][Using Emacs 17 - misc small packages]] | C'est la Z

#+begin_src emacs-lisp

;; Beacon Mode =============================================
;; flashes the cursor's line when you scroll

(use-package beacon
:ensure t
:config
(beacon-mode 1)
; this color looks good for the zenburn theme but not for the one
; I'm using for the videos
(setq beacon-color "#666600")
)
#+end_src

#+RESULTS:
:RESULTS:
t
:END:
** Nyan Mode

Okay, this was stupid, installed it because I was bored, and yes it
shows the famous pop-tart cat in your mode-line.  It's really not
worth it.  But someone at work thought that nyan-cat was an emacs
thing and I thought, no.  But I wouldn't be surprised it if was.

Can't work out how to kill it.  Well, it won't be loaded when I
reboot, so there is that....

NOT tangled.

#+begin_src emacs-lisp :tangle no
(use-package  nyan-mode
 :ensure 
 :config
(nyan-mode 1))
#+end_src

#+RESULTS:
:RESULTS:
t
:END:
** Calfw 

There is a package available for GCal integration as well.

  - [[https://github.com/kiwanami/emacs-calfw][kiwanami/emacs-calfw]] | GitHub
  - [[http://jameswilliams.be/blog/2016/01/11/Taming-Your-GCal.html][Taming Google Calendar With Org-Mode]]

This has been a 


#+begin_src emacs-lisp

  ;; Calfw ===================================================

  (use-package calfw
    :ensure t 
    :config
     (require 'calfw-org)
     (setq cfw:org-overwrite-default-keybinding t)
     ;;(setq cfw:org-agenda-schedule-args '(:timestamp))

     (define-key global-map "\C-cq" 'cfw:open-org-calendar)
  )


     (setq calendar-day-name-array
	["日" "月" "火" "水" "木" "金" "土"])

     ;; Default setting
     (setq cfw:fchar-junction ?+
	cfw:fchar-vertical-line ?|
	cfw:fchar-horizontal-line ?-
	cfw:fchar-left-junction ?+
	cfw:fchar-right-junction ?+
	cfw:fchar-top-junction ?+
	cfw:fchar-top-left-corner ?+
	cfw:fchar-top-right-corner ?+ )

     ;; Unicode characters
     ;; (setq cfw:fchar-junction ?╋
     ;;       cfw:fchar-vertical-line ?┃
     ;;       cfw:fchar-horizontal-line ?━
     ;;       cfw:fchar-left-junction ?┣
     ;;       cfw:fchar-right-junction ?┫
     ;;       cfw:fchar-top-junction ?┯
     ;;       cfw:fchar-top-left-corner ?┏
     ;;       cfw:fchar-top-right-corner ?┓)

  (custom-set-faces
   '(cfw:face-title ((t (:foreground "darkgoldenrod3" :weight bold :height 2.0 :inherit variable-pitch))))
   '(cfw:face-header ((t (:foreground "maroon2" :weight bold))))
   '(cfw:face-sunday ((t :foreground "red" :weight bold)))
   '(cfw:face-saturday ((t :foreground "blue" :weight bold)))
   '(cfw:face-holiday ((t :background "grey10" :foreground "purple" :weight bold)))
   '(cfw:face-default-content ((t :foreground "green2" )))
   '(cfw:face-regions ((t :foreground "cyan")))
   '(cfw:face-day-title ((t :background "grey10")))
   '(cfw:face-today-title ((t :background "red4" :weight bold)))
   '(cfw:face-today ((t :foreground: "cyan" :weight bold)))
   '(cfw:face-select ((t :background "blue4")))
   '(cfw:face-toolbar-button-off ((t :foreground "cyan" :weight bold)))
   '(cfw:face-toolbar-button-on ((t :foreground "Gray50" :weight bold)))
  ;;  '(cfw:face-grid ((t :foreground "DarkGrey")))
  ;;  '(cfw:face-default-day ((t :weight bold :inherit cfw:face-day-title)))
  ;;  '(cfw:face-annotation ((t :foreground "RosyBrown" :inherit cfw:face-day-title)))
   )

#+end_src

#+RESULTS:
:RESULTS:
nil
:END:


** Chronos

 - [[https://github.com/dxknight/chronos][dxknight/chronos: Chronos]] | Github

#+begin_src emacs-lisp

;; Chronos =================================================
 (use-package chronos 
   :ensure t
   :init
 (setq chronos-expiry-functions '(chronos-buffer-notify
                                  chronos-dunstify))
)

#+end_src

#+RESULTS:
:RESULTS:
nil
:END:

** Helm-chronos

 - [[https://github.com/dxknight/helm-chronos][dxknight/helm-chronos]] | GitHub

#+begin_src emacs-lisp

;; Helm Chronos ============================================
 (use-package helm-chronos
   :ensure t
   :init
 (setq helm-chronos-standard-timers
   '( "   1/You Win!"
      "   2/Drink Beer!"
      "   4/Soak noodles"
      "  25/Pomodoro: Work on helm-chronos + 5/Pomodoro: Rest"))
)

#+end_src

#+RESULTS:
:RESULTS:
nil
:END:
